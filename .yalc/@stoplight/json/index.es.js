import{isObject as e,cloneDeep as r,get as t,set as n,has as o,setWith as i,trimStart as s}from"lodash";import{createScanner as a,findNodeAtOffset as c,getNodePath as l,visit as u,printParseErrorCode as f}from"jsonc-parser";import p,{getOrder as h,ORDER_KEY_ID as y}from"@stoplight/ordered-object-literal";import{DiagnosticSeverity as g}from"@stoplight/types";import d from"safe-stable-stringify";const b=r=>e(r)&&"$ref"in r&&"string"==typeof r.$ref,m=e=>e.length>0&&("#"===e||/^#\S*$/.test(e)),w=(e,r,t)=>{const n=e.toString();let o="",i=n,s=0,a=i.indexOf(r);for(;a>-1;)o+=n.substring(s,s+a)+t,i=i.substring(a+r.length,i.length),s+=a+r.length,a=i.indexOf(r);return i.length>0&&(o+=n.substring(n.length-i.length,n.length)),o},v=e=>"number"==typeof e?e:w(w(e,"~","~0"),"/","~1"),O=e=>j(e),j=e=>{if(e&&"object"!=typeof e)throw new TypeError("Invalid type: path must be an array of segments.");return 0===e.length?"#":`#/${e.map(v).join("/")}`};function A(e){try{return decodeURIComponent(e)}catch(r){return e}}const E=/%[0-9a-f]+/gi,$=e=>{let r;try{r=decodeURIComponent(e)}catch(t){r=e.replace(E,A)}return w(w(r,"~1","/"),"~0","~")},x=e=>S(e),S=e=>{if("string"!=typeof e)throw new TypeError("Invalid type: JSON Pointers are represented as strings.");if(0===e.length||"#"!==e[0])throw new URIError("Invalid JSON Pointer syntax; URI fragment identifiers must begin with a hash.");if(1===e.length)return[];if("/"!==e[1])throw new URIError("Invalid JSON Pointer syntax.");return(e=>{const r=e.length,t=[];let n=-1;for(;++n<r;)t.push($(e[n]));return t})(e.substring(2).split("/"))},_=e=>{if("string"!=typeof e||0===e.length||m(e))return null;const r=e.indexOf("#");return-1===r?e:e.slice(0,r)};function k(e){if("object"!=typeof e||null===e)return!1;const r=Object.getPrototypeOf(e);return null===r||r===Object.prototype||"function"==typeof e.constructor&&Function.toString.call(Object)===Function.toString.call(e.constructor)}function N(e,r,t,n){if(null!==_(r))throw new ReferenceError("Cannot resolve external references");const o=x(r);let i=o,s=e;for(const[a,c]of o.entries()){if(!k(s)&&!Array.isArray(s)||!(c in s))throw new ReferenceError(`Could not resolve '${r}'`);if(k(s=s[c])&&"$ref"in s){if("string"!=typeof s.$ref)throw new TypeError("$ref should be a string");if(t.includes(s))return{location:n||i,value:t[t.length-1]};t.push(s),({value:s,location:i}=N(e,s.$ref,t,i)),i.push(...o.slice(a+1))}}if(0===t.length)return{location:i,value:s};const a=t[t.length-1];return k(a)&&("summary"in a||"description"in a)?{location:i,value:Object.assign(Object.assign(Object.assign({},s),"description"in a?{description:a.description}:null),"summary"in a?{summary:a.summary}:null)}:{location:i,value:s}}function P(e,r){return N(e,r,[]).value}function T(e,r){return N(e,r,[])}const I=(e,r,t)=>{const n={value:e,path:t};r.onEnter&&r.onEnter(n);for(const n of Object.keys(e)){const o=e[n];r.onProperty&&r.onProperty({parent:e,parentPath:t,property:n,propertyValue:o}),"object"==typeof o&&null!==o&&I(o,r,t.concat(n))}r.onLeave&&r.onLeave(n)},R=(e,r)=>{"object"==typeof e&&null!==e&&I(e,"function"==typeof r?{onProperty:r}:r,[])},K="#/__bundled__",M="#/__errors__",U=({document:e,path:t,bundleRoot:n="#/__bundled__",errorsRoot:o="#/__errors__",cloneDocument:i=!0},s)=>{if(t===n||t===o)throw new Error("Roots do not make any sense");const a=i?r(e):e;return C(a,x(n),x(o))(t,{[t]:!0},s)},C=(e,r,s)=>{const a=new Set,c=(l,u,f,p={},h={},y={})=>{const g=x(l),d=t(e,g);R(f||d,({parent:s})=>{if(b(s)&&m(s.$ref)){const f=s.$ref;if(y[f])return;if(p[f])return void(s.$ref=p[f]);let g,d,b,m,w;try{let n;if(g=x(f),Array.isArray(t(e,g.slice(0,-1)))){n=`${g[g.length-2]}_${g[g.length-1]}`}else n=g[g.length-1];b=n;let o=1;for(;a.has(b);)if(b=`${n}_${++o}`,o>20)throw new Error(`Keys ${n}_2 through ${n}_20 already taken.`);a.add(b),d=[...r,b],m=O(d)}catch(e){y[f]=e.message}if(!g||!d||!m)return;if("object"==typeof e&&null!==e)try{w=P(Object(e),f)}catch(r){w=t(e,g)}void 0!==w&&(p[f]=m,s.$ref=m,o(h,d)||(Array.isArray(w)?n(h,d,new Array(w.length).fill(null)):"object"==typeof w&&i(h,d,{},Object),n(h,d,w),u[f]||(u[f]=!0,c(l,u,w,p,h,y),u[f]=!1)))}});const w=t(h,r);return w&&Object.keys(w).length&&n(d,r,w),(Object.keys(y).length||o(e,s))&&n(d,s,o(e,s)?t(e,s):y),d};return c},D=e=>w(w(e,"~1","/"),"~0","~"),J=(e,r)=>{const t=new WeakMap;return function e(n,o){let i;if(r&&(n=r(n)),k(n)||Array.isArray(n)){const r=t.get(n);return r?{$ref:r}:(t.set(n,O(o)),Array.isArray(n)?i=n.map((r,t)=>e(r,[...o,String(t)])):(i={},Object.keys(n).forEach(r=>{i[r]=e(n[r],[...o,r])})),t.delete(n),i)}return n}(e,[])},V=e=>w(w(e,"~","~0"),"//","/~1"),F=e=>{if("string"!=typeof e||0===e.length)return null;const r=e.indexOf("#");return-1===r?null:e.slice(r)},L=e=>{const r=a(e,!0);if(r.scan(),1!==r.getToken())return;if(r.scan(),2===r.getToken())return;if(10!==r.getToken())throw new SyntaxError("Unexpected character");const t=r.getTokenValue();if(r.scan(),6!==r.getToken())throw new SyntaxError("Colon expected");switch(r.scan(),r.getToken()){case 10:return[t,r.getTokenValue()];case 11:return[t,Number(r.getTokenValue())];case 8:return[t,!0];case 9:return[t,!1];case 7:return[t,null];case 16:throw new SyntaxError("Unexpected character");case 17:throw new SyntaxError("Unexpected end of file");default:return}},W=({lineMap:e,ast:r},t)=>{const n=e[t.line],o=e[t.line+1];if(void 0===n)return;const i=c(r,void 0===o?n+t.character:Math.min(o,n+t.character),!0);if(void 0===i)return;const s=l(i);return 0!==s.length?s:void 0};function B(e){return D(e.split("/").pop()||"")}const q=({lineMap:e,ast:r},t,n=!1)=>{const o=function(e,r,t){e:for(const n of r){const r=Number.isInteger(Number(n))?Number(n):n;if("string"==typeof r||"number"==typeof r&&"array"!==e.type){if("object"!==e.type||!Array.isArray(e.children))return t?e:void 0;for(const t of e.children)if(Array.isArray(t.children)&&t.children[0].value===String(r)&&2===t.children.length){e=t.children[1];continue e}return t?e:void 0}if("array"!==e.type||r<0||!Array.isArray(e.children)||r>=e.children.length)return t?e:void 0;e=e.children[r]}return e}(r,t,n);if(void 0!==o&&void 0!==o.range)return{range:o.range}};const z=(e,r={disallowComments:!0})=>{const t=[],{ast:n,data:o,lineMap:i}=G(e,t,r);return{data:o,diagnostics:t,ast:n,lineMap:i}};function G(e,r=[],t){const n=Q(e);let o={type:"array",offset:-1,length:-1,children:[],parent:void 0},i=null,s=[];const a=new WeakMap,c=[];function l(e){"property"===o.type&&(o.length=e-o.offset,o=o.parent)}function y(e,r,t){return{start:{line:e,character:r},end:{line:e,character:r+t}}}function d(e){return o.children.push(e),e}function b(e){Array.isArray(s)?s.push(e):null!==i&&(s[i]=e)}function m(e){b(e),c.push(s),s=e,i=null}function w(){s=c.pop()}u(e,{onObjectBegin:(e,r,n,i)=>{o=d({type:"object",offset:e,length:-1,parent:o,children:[],range:y(n,i,r)}),!1===t.ignoreDuplicateKeys&&a.set(o,[]),m(function(e){return e?p({}):{}}(!0===t.preserveKeyOrder))},onObjectProperty:(e,n,c,l,u)=>{if((o=d({type:"property",offset:n,length:-1,parent:o,children:[]})).children.push({type:"string",value:e,offset:n,length:c,parent:o}),!1===t.ignoreDuplicateKeys){const t=a.get(o.parent);t&&(0!==t.length&&t.includes(e)?r.push({range:y(l,u,c),message:"DuplicateKey",severity:g.Error,path:X(o),code:20}):t.push(e))}!0===t.preserveKeyOrder&&function(e,r){if(!(r in e))return;const t=h(e),n=t.indexOf(r);-1!==n&&(t.splice(n,1),t.push(r))}(s,e),i=e},onObjectEnd:(e,r,n,i)=>{!1===t.ignoreDuplicateKeys&&a.delete(o),o.length=e+r-o.offset,o.range&&(o.range.end.line=n,o.range.end.character=i+r),o=o.parent,l(e+r),w()},onArrayBegin:(e,r,t,n)=>{o=d({type:"array",offset:e,length:-1,parent:o,children:[],range:y(t,n,r)}),m([])},onArrayEnd:(e,r,t,n)=>{o.length=e+r-o.offset,o.range&&(o.range.end.line=t,o.range.end.character=n+r),o=o.parent,l(e+r),w()},onLiteralValue:(e,r,t,n,i)=>{d({type:H(e),offset:r,length:t,parent:o,value:e,range:y(n,i,t)}),l(r+t),b(e)},onSeparator:(e,r,t)=>{"property"===o.type&&(":"===e?o.colonOffset=r:","===e&&l(r))},onError:(e,t,n,o,i)=>{r.push({range:y(o,i,n),message:f(e),severity:g.Error,code:e})}},t);const v=o.children[0];return v&&delete v.parent,{ast:v,data:s[0],lineMap:n}}function H(e){switch(typeof e){case"boolean":return"boolean";case"number":return"number";case"string":return"string";default:return"null"}}const Q=e=>{const r=[0];let t=0;for(;t<e.length;t++)"\n"===e[t]&&r.push(t+1);return r.push(t+1),r};function X(e,r=[]){return"property"===e.type&&r.unshift(e.children[0].value),void 0!==e.parent?("array"===e.parent.type&&void 0!==e.parent.parent&&r.unshift(e.parent.children.indexOf(e)),X(e.parent,r)):r}const Y=(e,r,t)=>{if(!e||!Object.hasOwnProperty.call(e,r)||r===t)return e;const n={};for(const[o,i]of Object.entries(e))o===r?n[t]=i:o in n||(n[o]=i);return n};function Z(e){return k(e)||Array.isArray(e)}function ee(e,r,t){if(t.length<=1||r.length<=1)throw Error("Source/target path must not be empty and point at root");if(0===r.indexOf(t))throw Error("Target path cannot be contained within source");const n=x(r);let o=e;for(const e of n){if(!Z(o))return;o=o[e]}if(!Z(o))return;const i=x(t);let s=e;for(const[e,r]of i.entries()){if(!Z(s)||r in s)return;const t=e===i.length-1?o:{};s[r]=t,s=t}delete e[n[0]],function e(r,t,n){for(const o of Object.keys(r)){const i=r[o];if("$ref"!==o)Z(i)&&e(i,t,n);else{if("string"!=typeof i||!m(i))continue;0===i.indexOf(t)&&(r[o]=i.replace(t,n))}}}(e,r,t)}const re=(e,r)=>{if("string"!=typeof e)return e;try{const t=te(e);return"string"==typeof t?t:JSON.parse(e,r)}catch(e){return}},te=e=>{const r=Number(e);return Number.isFinite(r)?String(r)===e?r:e:NaN},ne=(e,r,t)=>{if("string"==typeof e)return e;try{return JSON.stringify(e,r,t)}catch(n){return d(e,r,t)}},oe=(e,r)=>{if(e instanceof Array){if(r instanceof Array){if(r.length>e.length)return!1;for(const t in r){if(!r.hasOwnProperty(t))continue;const n=parseInt(e[t]),o=parseInt(r[t]);if(isNaN(n)&&isNaN(o)){if(e[t]!==r[t])return!1}else if(n!==o)return!1}}}else{if("string"!=typeof e)return!1;if("string"==typeof r)return e.startsWith(r)}return!0},ie=(e,r,t)=>{const n=ne(e,r,t);if(void 0===n)throw new Error("The value could not be stringified");return n};function se(e){return e.replace(/^(\/|#\/)/,"").split("/").map(D).map(ae).join(".")}function ae(e){return e.includes(".")?`["${e.replace(/"/g,'\\"')}"]`:e}const ce=Symbol.for(y),le={ownKeys:e=>ce in e?e[ce]:Reflect.ownKeys(e)},ue=e=>new Proxy(e,le);function fe(e,r){if("string"==typeof e&&"string"==typeof r)return s(e,r);if(!(e&&Array.isArray(e)&&e.length&&r&&Array.isArray(r)&&r.length))return e;let t=0;for(const n in e)if(e.hasOwnProperty(n)){if(e[n]!==r[n])break;t++}return e.slice(t)}export{K as BUNDLE_ROOT,M as ERRORS_ROOT,ce as KEYS,U as bundleTarget,$ as decodePointer,D as decodePointerFragment,J as decycle,V as encodePointer,v as encodePointerFragment,F as extractPointerFromRef,_ as extractSourceFromRef,L as getFirstPrimitiveProperty,W as getJsonPathForPosition,B as getLastPathSegment,q as getLocationForJsonPath,b as hasRef,m as isLocalRef,k as isPlainObject,G as parseTree,z as parseWithPointers,O as pathToPointer,x as pointerToPath,Y as renameObjectKey,ee as reparentBundleTarget,P as resolveInlineRef,T as resolveInlineRefWithLocation,re as safeParse,ne as safeStringify,oe as startsWith,ie as stringify,se as toPropertyPath,ue as trapAccess,R as traverse,fe as trimStart};
